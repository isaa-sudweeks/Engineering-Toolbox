import { MarkdownView, Notice, TFile, normalizePath } from "obsidian";
import type EngineeringToolkitPlugin from "./main";
import type { NoteScope } from "./utils/types";
import type { EvaluatedLine } from "./calcEngine";

interface EvaluatedBlock {
  source: string;
  entries: EvaluatedLine[];
}

export class PythonExporter {
  constructor(private plugin: EngineeringToolkitPlugin) {}

  async exportActiveNoteOrSelection(): Promise<void> {
    const view = this.plugin.app.workspace.getActiveViewOfType(MarkdownView);
    if (!view || !view.file) {
      new Notice("Open a markdown note to export calculations");
      return;
    }

    const file = view.file;
    const editor = view.editor;
    const selection = editor.getSelection();
    const hasSelection = !!selection.trim();
    const content = hasSelection ? selection : await this.plugin.app.vault.read(file);

    const blocks = this.extractCalcBlocks(content);
    if (!blocks.length) {
      new Notice("No calc code blocks found to export");
      return;
    }

    const workingScope: NoteScope = { vars: new Map() };
    const evaluated: EvaluatedBlock[] = [];
    let firstBlock = true;
    for (const block of blocks) {
      const { entries } = this.plugin.calc.evaluateToEntries(block, file.path, {
        persist: false,
        scope: workingScope,
        resetScope: firstBlock
      });
      evaluated.push({ source: block, entries });
      firstBlock = false;
    }

    try {
      await this.persistExport(file, evaluated, hasSelection);
    } catch (err: any) {
      console.error("Engineering Toolkit export failed", err);
      new Notice(`Failed to export calculations: ${err?.message ?? String(err)}`);
    }
  }

  private extractCalcBlocks(content: string): string[] {
    const regex = /```calc\s*\n([\s\S]*?)```/g;
    const blocks: string[] = [];
    let match: RegExpExecArray | null;
    while ((match = regex.exec(content)) !== null) {
      blocks.push(match[1]);
    }
    return blocks;
  }

  private async persistExport(file: TFile, blocks: EvaluatedBlock[], isSelection: boolean): Promise<void> {
    const settings = this.plugin.settings;
    const folder = settings.exportOutputFolder?.trim() ?? "";
    const format = settings.exportFormat ?? "script";
    const baseName = this.makeBaseName(file, isSelection);
    const fileName = format === "notebook" ? `${baseName}.ipynb` : `${baseName}.py`;
    const targetPath = normalizePath(folder ? `${folder}/${fileName}` : fileName);

    await this.ensureFolder(folder);

    const data = format === "notebook"
      ? this.buildNotebook(blocks)
      : this.buildScript(blocks);

    const existing = this.plugin.app.vault.getAbstractFileByPath(targetPath);
    if (existing instanceof TFile) {
      await this.plugin.app.vault.modify(existing, data);
    } else {
      await this.plugin.app.vault.create(targetPath, data);
    }

    new Notice(`Exported calculations to ${targetPath}`);
  }

  private async ensureFolder(folder: string): Promise<void> {
    if (!folder) return;
    const normalized = normalizePath(folder);
    if (await this.plugin.app.vault.adapter.exists(normalized)) return;
    await this.plugin.app.vault.createFolder(normalized).catch(() => {});
  }

  private makeBaseName(file: TFile, isSelection: boolean): string {
    const base = file.basename.replace(/[^A-Za-z0-9-_]+/g, "_");
    if (!isSelection) return `${base}-calc-export`;
    return `${base}-selection-${Date.now()}`;
  }

  private buildScript(blocks: EvaluatedBlock[]): string {
    const lines = this.buildScriptLines(blocks);
    return lines.join("\n") + "\n";
  }

  private buildScriptLines(blocks: EvaluatedBlock[]): string[] {
    const timestamp = new Date().toISOString();
    const lines: string[] = [
      "# Generated by Engineering Toolkit",
      `# Exported on ${timestamp}`,
      "from typing import Any, Dict",
      "",
      "results: Dict[str, Any] = {}",
      ""
    ];

    for (const block of blocks) {
      lines.push("# --- calc block ---");
      for (const entry of block.entries) {
        switch (entry.type) {
          case "blank":
            lines.push("");
            break;
          case "comment":
            lines.push(`# ${entry.line.replace(/^#\s*/, "")}`);
            break;
          case "assignment": {
            const name = this.pythonIdentifier(entry.name ?? "value");
            const literal = this.pythonLiteral(entry);
            const exprComment = entry.expr ? `  # ${entry.expr}` : "";
            const displayComment = entry.display ? `  # ${entry.display}` : "";
            lines.push(`${name} = ${literal}${exprComment}`);
            lines.push(`results["${name}"] = ${name}${displayComment}`);
            break;
          }
          case "convert": {
            const expr = entry.expr ?? "";
            const target = entry.target ?? "";
            const display = entry.display ?? "";
            const comment = [`# convert:`, expr, "->", target, "=", display].filter(Boolean).join(" ");
            lines.push(comment);
            break;
          }
          case "expression": {
            const expr = entry.expr ?? "";
            const display = entry.display ?? "";
            const comment = expr && display ? `# ${expr} = ${display}` : `# ${expr || display}`;
            lines.push(comment);
            break;
          }
          case "error":
            lines.push(`# ERROR: ${entry.error}`);
            break;
        }
      }
      lines.push("", "");
    }

    lines.push("print(\"Calculation results:\")");
    lines.push("for key, value in results.items():");
    lines.push("    print(f\"{key}: {value}\")");

    return lines;
  }

  private buildNotebook(blocks: EvaluatedBlock[]): string {
    const codeLines = this.buildScriptLines(blocks).map(line => line + "\n");
    const notebook = {
      cells: [
        {
          cell_type: "markdown",
          metadata: {},
          source: ["# Calculations Exported from Engineering Toolkit\n"]
        },
        {
          cell_type: "code",
          metadata: {},
          execution_count: null,
          outputs: [],
          source: codeLines
        }
      ],
      metadata: {
        kernelspec: {
          display_name: "Python 3",
          language: "python",
          name: "python3"
        },
        language_info: {
          name: "python",
          file_extension: ".py",
          mimetype: "text/x-python",
          codemirror_mode: { name: "ipython", version: 3 }
        }
      },
      nbformat: 4,
      nbformat_minor: 5
    };

    return JSON.stringify(notebook, null, 2);
  }

  private pythonIdentifier(name: string): string {
    const style = this.plugin.settings.exportVariableStyle ?? "preserve";
    const sanitized = name
      .replace(/[^A-Za-z0-9_\s]/g, " ")
      .replace(/\s+/g, " ")
      .trim();
    const base = sanitized || "value";
    let candidate = base;
    switch (style) {
      case "snake_case":
        candidate = this.toSnakeCase(base);
        break;
      case "camelCase":
        candidate = this.toCamelCase(base);
        break;
      default:
        candidate = base.replace(/\s+/g, "_");
    }
    candidate = candidate.replace(/^[^A-Za-z_]+/, "");
    if (!candidate) candidate = "value";
    return candidate;
  }

  private toSnakeCase(text: string): string {
    return text
      .replace(/([a-z0-9])([A-Z])/g, "$1_$2")
      .replace(/[^A-Za-z0-9]+/g, "_")
      .replace(/_{2,}/g, "_")
      .toLowerCase();
  }

  private toCamelCase(text: string): string {
    const parts = text
      .replace(/[^A-Za-z0-9]+/g, " ")
      .trim()
      .split(/\s+/);
    if (!parts.length) return "value";
    const [first, ...rest] = parts;
    return first.toLowerCase() + rest.map(p => p.charAt(0).toUpperCase() + p.slice(1).toLowerCase()).join("");
  }

  private pythonLiteral(entry: EvaluatedLine): string {
    const value = entry.value;
    if (typeof value === "number" && Number.isFinite(value)) return Number(value).toString();
    if (typeof value === "boolean") return value ? "True" : "False";
    if (typeof value === "string") return JSON.stringify(value);
    if (value && typeof (value as any).toNumber === "function" && typeof (value as any).formatUnits === "function") {
      try {
        const unitName = (value as any).formatUnits();
        const num = (value as any).toNumber(unitName);
        return `{"value": ${num}, "unit": "${unitName}"}`;
      } catch {
        return JSON.stringify(entry.display ?? String(value));
      }
    }
    return JSON.stringify(entry.display ?? String(value ?? ""));
  }
}
